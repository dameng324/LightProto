using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace LightProto.Generator;

[Generator(LanguageNames.CSharp)]
public partial class LightProtoGenerator : IIncrementalGenerator
{
    const string NewLine = "\r\n";
    public const string ProtoContractAttributeFullName = "LightProto.ProtoContractAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var symbols = context.SyntaxProvider.ForAttributeWithMetadataName(
            ProtoContractAttributeFullName,
            predicate: (node, _) =>
                node is ClassDeclarationSyntax or StructDeclarationSyntax or InterfaceDeclarationSyntax or RecordDeclarationSyntax,
            transform: (ctx, _) => ctx.TargetSymbol
        );

        var typesAndCompilation = symbols.Combine(context.CompilationProvider);
        context.RegisterSourceOutput(
            typesAndCompilation,
            (spc, pair) =>
            {
                var (type, compilation) = pair;
                try
                {
                    var contract = ProtoContract.GetProtoContract(compilation, type, spc);
                    if (contract is null)
                    {
                        return;
                    }

                    using var memoryStream = new MemoryStream();

                    using (var streamWriter = new StreamWriter(memoryStream, Encoding.UTF8, bufferSize: -1, leaveOpen: true))
                    {
                        CodeWriter writer = new(streamWriter);
                        GenerateBasicProtobufMessage(writer, contract, spc);
                    }
                    var fileName = $"{type}.LightProto.g.cs";
                    memoryStream.Position = 0;
                    spc.AddSource(fileName, SourceText.From(memoryStream, canBeEmbedded: true));
                }
                catch (LightProtoGeneratorException e)
                {
                    spc.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(e.Id, e.Title, e.Message, e.Category, e.Severity, isEnabledByDefault: true),
                            e.Location ?? Location.None,
                            additionalLocations: e.AdditionalLocations
                        )
                    );
                }
                catch (Exception e)
                {
                    spc.ReportDiagnostic(
                        Diagnostic.Create(
                            new DiagnosticDescriptor(
                                "LIGHT_PROTO_000",
                                "Unknown Exception",
                                e.ToString().Replace(NewLine, " "),
                                "Unknown",
                                DiagnosticSeverity.Error,
                                isEnabledByDefault: true
                            ),
                            Location.None
                        )
                    );
                }
            }
        );
    }

    public string Invoke(bool prediction, Func<string> ifTrue, Func<string> ifFalse)
    {
        return prediction ? ifTrue() : ifFalse();
    }

    public string Invoke(Func<bool> prediction, Func<string> ifTrue, Func<string> ifFalse)
    {
        return prediction() ? ifTrue() : ifFalse();
    }

    private void GenerateBasicProtobufMessage(CodeWriter writer, ProtoContract contract, SourceProductionContext spc)
    {
        var targetType = contract.Type;
        var namespaceDeclare = targetType.ContainingNamespace.IsGlobalNamespace
            ? ""
            : $"namespace {targetType.ContainingNamespace.ToDisplayString()}";

        var typeDeclarationString = targetType.IsValueType
            ? targetType.IsRecord
                ? "partial record struct"
                : "partial struct"
            : targetType.IsRecord
                ? "partial record"
                : targetType.TypeKind == TypeKind.Interface
                    ? "public sealed partial class"
                    : "partial class";
        var implicitFields = contract.ImplicitFields;
        var net8OrGreater = contract.TypeDeclaration.SyntaxTree.Options.PreprocessorSymbolNames.Contains("NET8_0_OR_GREATER");
        var protoMembers = contract.Members;

        writer.WriteLine(
            $"""
            // <auto-generated>
            //     Generated by {typeof(LightProtoGenerator).FullName} at {DateTime.Now:yyyy-MM-dd HH:mm:ss}
            // </auto-generated>

            #pragma warning disable 1591, 0612, 3021, 8981, CS9035, CS0109, CS8669, CS1570, CS0219, RS0016, RS0041
            using System;
            using System.Linq;
            using LightProto;
            """
        );
        writer.WriteLine(namespaceDeclare);
        using StackDisposable disposable = new();
        if (!string.IsNullOrWhiteSpace(namespaceDeclare))
        {
            writer.IndentScope().AddTo(disposable);
        }
        Helper.GenerateNestedClassStructure(writer, targetType).AddTo(disposable);

        writer.WriteLine("/// <summary>");
        writer.WriteLine($"/// Auto-generated IMessage implementation for {targetType.ToDisplayString()}");
        if (implicitFields is not ImplicitFields.None)
        {
            foreach (var member in protoMembers.OrderBy(x => x.FieldNumber))
            {
                writer.WriteLine($"/// {member.Name} FieldNumber: {member.FieldNumber} <br/>");
            }
        }
        writer.WriteLine("/// </summary>");
        if (targetType.TypeKind is not TypeKind.Interface)
        {
            writer.WriteLine("[global::System.Diagnostics.DebuggerDisplayAttribute(\"{ToString(),nq}\")]");
        }

        if (Helper.GetBaseProtoType(targetType) is not null || contract.DerivedTypeContracts.Any())
        {
            GenerateDerivedClassBody(writer, contract, spc, typeDeclarationString, net8OrGreater);
        }
        else
        {
            GenerateGeneralClassBody(writer, contract, typeDeclarationString, net8OrGreater);
        }
    }

    private void GenerateGeneralClassBody(CodeWriter writer, ProtoContract contract, string typeDeclarationString, bool net8OrGreater)
    {
        var targetType = contract.Type;
        if (targetType.TypeKind == TypeKind.Interface)
        {
            throw LightProtoGeneratorException.Interface_Must_Have_ProtoInclude(contract.TypeDeclaration.GetLocation());
        }

        var compilation = contract.Compilation;
        var className = targetType.Name;
        var proxyFor = contract.ProxyFor;
        bool skipConstructor = contract.SkipConstructor;
        var protoMembers = contract.Members;

        var proxyOrClassName = proxyFor?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) ?? className;
        writer.WriteLine($"{typeDeclarationString} {className} :IProtoParser<{proxyOrClassName}>");
        using (writer.IndentScope())
        {
            writer.WriteLine($"public static IProtoReader<{proxyOrClassName}> ProtoReader {{ get; }} = new LightProtoReader();");
            writer.WriteLine($"public static IProtoWriter<{proxyOrClassName}> ProtoWriter {{ get; }} = new LightProtoWriter();");

            GenerateLightProtoWriterClass(writer, proxyOrClassName, protoMembers, compilation, targetType, className);
            GenerateLightProtoReaderClass(
                writer,
                contract,
                net8OrGreater,
                proxyOrClassName,
                protoMembers,
                compilation,
                targetType,
                skipConstructor,
                className
            );
        }
    }

    private void GenerateLightProtoWriterClass(
        CodeWriter writer,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        INamedTypeSymbol targetType,
        string className
    )
    {
        writer.WriteLine($"internal sealed class LightProtoWriter:IProtoWriter,IProtoWriter<{proxyOrClassName}>");
        using (writer.IndentScope())
        {
            writer.WriteLine(
                $"void IProtoWriter.WriteTo(ref WriterContext output, object message) => WriteTo(ref output, ({proxyOrClassName})message);"
            );
            writer.WriteLine($"int IProtoWriter.CalculateSize(object message) => CalculateSize(({proxyOrClassName})message);");
            writer.WriteLine($"long IProtoWriter.CalculateLongSize(object message) => CalculateLongSize(({proxyOrClassName})message);");
            writer.WriteLine($"public bool IsMessage => true;");
            writer.WriteLine($"public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;");
            GenerateMemberProtoParsers(writer, protoMembers, compilation, targetType, "Writer");
            GenerateWriteToMethod(writer, proxyOrClassName, protoMembers, compilation, className);
            GenerateCalculateSizeMethod(writer, proxyOrClassName, protoMembers, compilation, className);
        }
    }

    private void GenerateCommonCalculateSizeMethod(
        CodeWriter writer,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        string className,
        Func<ProtoMember, string> getMemberAccess,
        Func<ProtoMember, string> getNullCheck,
        List<(uint RawTag, ProtoContract Contract)> derivedTypes
    )
    {
        writer.WriteLine($"public long CalculateLongSize({proxyOrClassName} value)");
        using (writer.IndentScope())
        {
            var valueToMessage = proxyOrClassName.Equals(className, StringComparison.Ordinal)
                ? $"ref {className} message = ref value;"
                : $"{className} message = value;";
            writer.WriteLine(valueToMessage);
            writer.WriteLine("long size=0;");
            foreach (var member in protoMembers)
            {
                var tagSize = member.RawTagSize;
                var memberAccess = getMemberAccess(member);
                var nullCheck = getNullCheck(member);
                writer.WriteLine($"if({nullCheck})");
                using (writer.IndentScope())
                {
                    if (Helper.IsCollectionType(compilation, member.Type) || Helper.IsDictionaryType(compilation, member.Type))
                        writer.WriteLine($"size += {member.Name}_ProtoWriter.CalculateLongSize({memberAccess}); ");
                    else if (TryGetInternalTypeName(member.Type, member.DataFormat, member.StringIntern, out var name))
                        writer.WriteLine($"size += {tagSize} + CodedOutputStream.Compute{name}Size({memberAccess});");
                    else
                        writer.WriteLine($"size += {tagSize} + {member.Name}_ProtoWriter.CalculateLongMessageSize({memberAccess});");
                }
            }

            foreach (var member in derivedTypes)
            {
                writer.WriteLine($"if(message.{member.Contract.Type.Name}_MemberStruct.HasValue)");
                using (writer.IndentScope(false))
                {
                    writer.WriteLine(
                        $"size += {ProtoMember.GetRawTagSize(member.RawTag)} + {member.Contract.Type}.MemberStructWriter.CalculateLongMessageSize(message.{member.Contract.Type.Name}_MemberStruct.Value); "
                    );
                }
            }
            writer.WriteLine("return size;");
        }

        writer.WriteLine($"public int CalculateSize({proxyOrClassName} value)");
        using (writer.IndentScope())
        {
            writer.WriteLine("var longSize = CalculateLongSize(value);");
            writer.WriteLine("if (longSize > int.MaxValue)");
            using (writer.IndentScope())
            {
                writer.WriteLine("throw new OverflowException(\"Calculated size exceeds Int32.MaxValue\");");
            }
            writer.WriteLine("return (int)longSize;");
        }
    }

    private void GenerateCalculateSizeMethod(
        CodeWriter writer,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        string className
    )
    {
        GenerateCommonCalculateSizeMethod(
            writer,
            proxyOrClassName,
            protoMembers,
            compilation,
            className,
            member => $"message.{member.Name}",
            member => member.GetCheckIfNotEmpty("message"),
            []
        );
    }

    private void GenerateCommonWriteToMethod(
        CodeWriter writer,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        string className,
        Func<ProtoMember, string> getMemberAccess,
        Func<ProtoMember, string> getNullCheck,
        List<(uint RawTag, ProtoContract Contract)> derivedTypes
    )
    {
        writer.WriteLine($"public void WriteTo(ref WriterContext output, {proxyOrClassName} value)");
        using (writer.IndentScope())
        {
            var valueToMessage = proxyOrClassName.Equals(className, StringComparison.Ordinal)
                ? $"ref {className} message = ref value;"
                : $"{className} message = value;";
            writer.WriteLine(valueToMessage);

            foreach (var member in protoMembers)
            {
                var memberAccess = getMemberAccess(member);
                var checkIfNotEmpty = getNullCheck(member);
                writer.WriteLine($"if({checkIfNotEmpty})");
                using (writer.IndentScope())
                {
                    if (Helper.IsCollectionType(compilation, member.Type) || Helper.IsDictionaryType(compilation, member.Type))
                    {
                        writer.WriteLine($"{member.Name}_ProtoWriter.WriteTo(ref output, {memberAccess});");
                    }
                    else if (TryGetInternalTypeName(member.Type, member.DataFormat, member.StringIntern, out var name))
                    {
                        writer.WriteLine($"output.WriteTag({member.RawTag}); ");
                        writer.WriteLine($"output.Write{name}({memberAccess});");
                    }
                    else
                    {
                        writer.WriteLine($"output.WriteTag({member.RawTag}); ");
                        writer.WriteLine($"{member.Name}_ProtoWriter.WriteMessageTo(ref output, {memberAccess});");
                    }
                }
            }
            foreach (var member in derivedTypes)
            {
                writer.WriteLine($"if(message.{member.Contract.Type.Name}_MemberStruct.HasValue) ");
                using (writer.IndentScope())
                {
                    writer.WriteLine($"output.WriteTag({member.RawTag});");
                    writer.WriteLine(
                        $"{member.Contract.Type}.MemberStructWriter.WriteMessageTo(ref output, message.{member.Contract.Type.Name}_MemberStruct.Value);"
                    );
                }
            }
        }
    }

    private void GenerateWriteToMethod(
        CodeWriter writer,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        string className
    )
    {
        GenerateCommonWriteToMethod(
            writer,
            proxyOrClassName,
            protoMembers,
            compilation,
            className,
            member => $"message.{member.Name}",
            member => member.GetCheckIfNotEmpty("message"),
            []
        );
    }

    private void GenerateLightProtoReaderClass(
        CodeWriter writer,
        ProtoContract contract,
        bool net8OrGreater,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        INamedTypeSymbol targetType,
        bool skipConstructor,
        string className
    )
    {
        writer.WriteLine($"internal sealed class LightProtoReader: IProtoReader, IProtoReader<{proxyOrClassName}>");
        using (writer.IndentScope())
        {
            writer.WriteLine("object IProtoReader.ParseFrom(ref ReaderContext input) => ParseFrom(ref input);");
            writer.WriteLine("public bool IsMessage => true;");
            writer.WriteLine("public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;");
            GenerateMemberProtoParsers(writer, protoMembers, compilation, targetType, "Reader");
            GenerateParseFromMethod(
                writer,
                contract,
                net8OrGreater,
                proxyOrClassName,
                protoMembers,
                compilation,
                skipConstructor,
                className
            );
        }
    }

    private void GenerateMemberProtoParsers(
        CodeWriter writer,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        INamedTypeSymbol targetType,
        string readerOrWriter
    )
    {
        foreach (
            var member in protoMembers.Where(member => !TryGetInternalTypeName(member.Type, member.DataFormat, member.StringIntern, out _))
        )
        {
            Helper.GetProtoParserMember(writer, compilation, member, readerOrWriter, targetType);
        }
    }

    private void GenerateParseFromMethod(
        CodeWriter writer,
        ProtoContract contract,
        bool net8OrGreater,
        string proxyOrClassName,
        List<ProtoMember> protoMembers,
        Compilation compilation,
        bool skipConstructor,
        string className
    )
    {
        writer.WriteLine($"public {proxyOrClassName} ParseFrom(ref ReaderContext input)");
        using (writer.IndentScope())
        {
            foreach (var member in protoMembers)
            {
                writer.WriteLine($"{member.Type} _{member.Name} = default;");
                writer.WriteLine($"bool _{member.Name}HasValue = false;");
            }

            writer.WriteLine("uint tag;");
            writer.WriteLine("while ((tag = input.ReadTag()) != 0)");
            using (writer.IndentScope())
            {
                writer.WriteLine("if ((tag & 7) == 4)");
                using (writer.IndentScope())
                {
                    writer.WriteLine("break;");
                }

                writer.WriteLine("switch(tag)");
                using (writer.IndentScope())
                {
                    writer.WriteLine("default:");
                    using (writer.IndentScope())
                    {
                        writer.WriteLine("input.SkipLastField();");
                        writer.WriteLine("break;");
                    }

                    foreach (var member in protoMembers)
                    {
                        writer.WriteLine($"case {member.RawTag}:");
                        if (Helper.IsCollectionType(compilation, member.Type))
                        {
                            var elementType = Helper.GetElementType(compilation, member.Type);
                            var tag2 = ProtoMember.GetRawTag(
                                member.FieldNumber,
                                ProtoMember.GetPbWireType(compilation, elementType, member.DataFormat)
                            );
                            if (tag2 != member.RawTag)
                            {
                                writer.WriteLine($"case {tag2}:");
                            }
                        }

                        using (writer.IndentScope())
                        {
                            writer.WriteLine($"_{member.Name}HasValue = true;");

                            if (TryGetInternalTypeName(member.Type, member.DataFormat, member.StringIntern, out var name))
                            {
                                writer.WriteLine($"_{member.Name} = input.Read{name}();");
                            }
                            else if (Helper.IsCollectionType(compilation, member.Type) || Helper.IsDictionaryType(compilation, member.Type))
                            {
                                writer.WriteLine($"_{member.Name} = {member.Name}_ProtoReader.ParseFrom(ref input);");
                            }
                            else
                            {
                                writer.WriteLine($"_{member.Name} = {member.Name}_ProtoReader.ParseMessageFrom(ref input);");
                            }

                            writer.WriteLine("break;");
                        }
                    }
                }
            }

            foreach (var member in protoMembers.Where(x => x.IsProtoMemberRequired))
            {
                writer.WriteLine($"if(_{member.Name}HasValue==false)");
                writer.WriteLine(
                    $"    throw new InvalidProtocolBufferException(\"ProtoMember:{contract.Type}.{member.Name} is required but not found when deserialization.\");"
                );
            }

            if (skipConstructor)
            {
                GenerateSkipConstructor(
                    writer,
                    net8OrGreater,
                    className,
                    contract.Members,
                    getMemberAccess: (member) => $"_{member.Name}",
                    getNullCheck: (member) => $"_{member.Name}HasValue"
                );
            }
            else
            {
                GenerateGeneralConstructor(
                    writer,
                    net8OrGreater,
                    className,
                    contract,
                    contract.Members,
                    getMemberAccess: (member) => $"_{member.Name}",
                    getNullCheck: (member) => $"_{member.Name}HasValue"
                );
            }

            writer.WriteLine("return parsed;");
        }
    }

    private static void CollectionAddWhenNotNet8OrGrater(CodeWriter writer, List<ProtoMember> protoMembers, bool net8OrGreater)
    {
        if (net8OrGreater)
            return;
        foreach (
            var member in protoMembers.Where(member =>
                member.IsReadOnly
                && (Helper.IsCollectionType(member.Compilation, member.Type) || Helper.IsDictionaryType(member.Compilation, member.Type))
            )
        )
        {
            writer.WriteLine($"if(parsed.{member.Name}!=null)");
            using (writer.IndentScope())
            {
                writer.WriteLine($"parsed.{member.Name}.Clear();");
                writer.WriteLine($"if(_{member.Name}!=null)");
                using (writer.IndentScope())
                {
                    if (Helper.IsStackType(member.Type))
                        writer.WriteLine($"foreach(var v in _{member.Name}.Reverse())");
                    else
                        writer.WriteLine($"foreach(var v in _{member.Name})");

                    using (writer.IndentScope())
                    {
                        if (Helper.IsStackType(member.Type))
                            writer.WriteLine($"parsed.{member.Name}.Push(v);");
                        else if (Helper.IsQueueType(member.Type))
                            writer.WriteLine($"parsed.{member.Name}.Enqueue(v);");
                        else if (Helper.IsDictionaryType(member.Compilation, member.Type))
                            writer.WriteLine($"parsed.{member.Name}[v.Key]=v.Value;");
                        else
                            writer.WriteLine($"parsed.{member.Name}.Add(v);");
                    }
                }
            }
        }
    }

    static string GetUninitializedObject(string className, bool net8OrGreater)
    {
        return net8OrGreater
            ? $"({className})System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(typeof({className}))"
            : $"({className})System.Runtime.Serialization.FormatterServices.GetUninitializedObject(typeof({className}))";
    }

    static void GenerateSkipConstructor(
        CodeWriter writer,
        bool net8OrGreater,
        string className,
        List<ProtoMember> protoMembers,
        Func<ProtoMember, string> getMemberAccess,
        Func<ProtoMember, string> getNullCheck
    )
    {
        writer.WriteLine($"var parsed = {GetUninitializedObject(className, net8OrGreater)};");
        foreach (var member in protoMembers)
        {
            var nullCheck = getNullCheck(member);
            var valueAccess = getMemberAccess(member);
            writer.WriteLine($"if ({nullCheck})");
            using (writer.IndentScope())
            {
                if (member.IsReadOnly || member.IsInitOnly)
                {
                    if (net8OrGreater)
                    {
                        AssignReadonlyMemberWithUnsafeAccessor(writer, member, valueAccess);
                    }
                    else
                    {
                        throw LightProtoGeneratorException.InitOnlyOrReadOnlyWhenSkipConstructor(
                            member.Name,
                            member.DeclarationSyntax.GetLocation()
                        );
                    }
                }
                else
                {
                    writer.WriteLine($"if ({nullCheck}) parsed.{member.Name} = {valueAccess};");
                }
            }
        }

        CollectionAddWhenNotNet8OrGrater(writer, protoMembers, net8OrGreater);
    }

    static void GenerateGeneralConstructor(
        CodeWriter writer,
        bool net8OrGreater,
        string className,
        ProtoContract contract,
        List<ProtoMember> protoMembers,
        Func<ProtoMember, string> getMemberAccess,
        Func<ProtoMember, string> getNullCheck
    )
    {
        var compilation = contract.Compilation;
        if (!contract.Type.Constructors.Any(x => x.Parameters.Length == 0))
        {
            throw LightProtoGeneratorException.No_Parameterless_Constructor(
                contract.Type.ToDisplayString(),
                contract.TypeDeclaration.GetLocation()
            );
        }

        var unsafeAccessorMember = new List<ProtoMember>();
        var generalMembers = new List<ProtoMember>();
        writer.WriteLine($"var parsed = new {className}()");
        using (writer.IndentScope(braceEnd: "};"))
        {
            foreach (var member in protoMembers)
            {
                if (member.IsReadOnly)
                {
                    if (net8OrGreater)
                    {
                        unsafeAccessorMember.Add(member);
                        writer.WriteLine($"// {member.Name} is readonly use UnsafeAccessor to assign value");
                    }
                    else if (Helper.IsCollectionType(compilation, member.Type) || Helper.IsDictionaryType(compilation, member.Type))
                    {
                        writer.WriteLine($"// {member.Name} is readonly");
                    }
                    else
                    {
                        throw LightProtoGeneratorException.ReadOnlyMemberCannotInitialize(
                            $"{contract.Type}.{member.Name}",
                            member.DeclarationSyntax.GetLocation()
                        );
                    }
                }
                else if (member.IsInitOnlyOrRequired)
                {
                    writer.WriteLine($"{member.Name} = {getNullCheck(member)} ? {getMemberAccess(member)} : {member.Initializer},");
                }
                else
                {
                    generalMembers.Add(member);
                }
            }
        }
        foreach (var member in unsafeAccessorMember)
        {
            writer.WriteLine($"if ({getNullCheck(member)})");
            using (writer.IndentScope())
            {
                if (net8OrGreater)
                {
                    AssignReadonlyMemberWithUnsafeAccessor(writer, member, getMemberAccess(member));
                }
                else
                {
                    throw LightProtoGeneratorException.InitOnlyOrReadOnlyWhenSkipConstructor(
                        member.Name,
                        member.DeclarationSyntax.GetLocation()
                    );
                }
            }
        }

        foreach (var member in generalMembers)
        {
            writer.WriteLine($"if ({getNullCheck(member)}) parsed.{member.Name} = {getMemberAccess(member)};");
        }

        CollectionAddWhenNotNet8OrGrater(writer, protoMembers, net8OrGreater);
    }

    static void GenDerivedLightProtoWriter(CodeWriter writer, string proxyOrClassName, string writerName, string message)
    {
        writer.WriteLine($"internal sealed class LightProtoWriter: IProtoWriter, IProtoWriter<{proxyOrClassName}>");
        using (writer.IndentScope())
        {
            writer.WriteLine(
                $"void IProtoWriter.WriteTo(ref WriterContext output, object message) => WriteTo(ref output, ({proxyOrClassName})message);"
            );
            writer.WriteLine($"int IProtoWriter.CalculateSize(object message) => CalculateSize(({proxyOrClassName})message);");
            writer.WriteLine($"long IProtoWriter.CalculateLongSize(object message) => CalculateLongSize(({proxyOrClassName})message);");
            writer.WriteLine($"public bool IsMessage => true;");
            writer.WriteLine($"public WireFormat.WireType WireType => WireFormat.WireType.LengthDelimited;");
            writer.WriteLine(
                $"public void WriteTo(ref WriterContext output, {proxyOrClassName} message) => {writerName}.WriteTo(ref output, {message});"
            );
            writer.WriteLine($"public int CalculateSize({proxyOrClassName} message) => {writerName}.CalculateSize({message});");
            writer.WriteLine($"public long CalculateLongSize({proxyOrClassName} message) => {writerName}.CalculateLongSize({message});");
        }
    }

    private static void AssignReadonlyMemberWithUnsafeAccessor(CodeWriter writer, ProtoMember member, string valueAccess)
    {
        string fieldName;
        // Check for compiler-generated backing field for auto-properties
        var backingFieldName = $"<{member.Name}>k__BackingField";
        if (member.ContractType.GetMembers(backingFieldName).Length > 0)
        {
            fieldName = backingFieldName;
        }
        // Check for explicit readonly field
        else if (member.ContractType.GetMembers(member.Name).OfType<IFieldSymbol>().Any())
        {
            fieldName = member.Name;
        }
        else
        {
            throw LightProtoGeneratorException.CannotFindReadonlyMemberFieldName(
                $"{member.ContractType}.{member.Name}",
                member.DeclarationSyntax.GetLocation()
            );
        }

        writer.WriteLine(
            $"[System.Runtime.CompilerServices.UnsafeAccessor(System.Runtime.CompilerServices.UnsafeAccessorKind.Field, Name = \"{fieldName}\")]"
        );
        writer.WriteLine(
            $"static extern ref {member.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} Get_{member.Name}_Field({member.ContractType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} message);"
        );
        writer.WriteLine($"ref var ref_{member.Name} = ref Get_{member.Name}_Field(parsed);");
        writer.WriteLine($"ref_{member.Name} = {valueAccess};");
    }

    private static bool TryGetInternalTypeName(ITypeSymbol memberType, DataFormat format, bool stringIntern, out string name)
    {
        name = memberType.SpecialType switch
        {
            SpecialType.System_Boolean => "Bool",
            SpecialType.System_Byte => format == DataFormat.FixedSize ? "FixedByte" : "Byte",
            SpecialType.System_SByte => format == DataFormat.FixedSize ? "SFixedByte"
            : format == DataFormat.ZigZag ? "SSByte"
            : "SByte",
            SpecialType.System_Int32 => format == DataFormat.FixedSize ? "SFixed32"
            : format == DataFormat.ZigZag ? "SInt32"
            : "Int32",
            SpecialType.System_UInt32 => format == DataFormat.FixedSize ? "Fixed32" : "UInt32",
            SpecialType.System_Int64 => format == DataFormat.FixedSize ? "SFixed64"
            : format == DataFormat.ZigZag ? "SInt64"
            : "Int64",
            SpecialType.System_UInt64 => format == DataFormat.FixedSize ? "Fixed64" : "UInt64",
            SpecialType.System_Single => "Float",
            SpecialType.System_Double => "Double",
            SpecialType.System_String when stringIntern is false => "String",
            _ => "",
        };
        return !string.IsNullOrWhiteSpace(name);
    }
}
